
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20160615 (GIT 4ac7450)
//----------------------------------------------------

import java_cup.runtime.*;
import java_cup.runtime.XMLElement;

/** CUP v0.11b 20160615 (GIT 4ac7450) generated parser.
  */
@SuppressWarnings({"rawtypes"})
public class parser extends java_cup.runtime.lr_parser {

 public final Class getSymbolContainer() {
    return sym.class;
}

  /** Default constructor. */
  @Deprecated
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\030\000\002\002\004\000\002\004\010\000\002\004" +
    "\007\000\002\005\004\000\002\005\003\000\002\006\010" +
    "\000\002\002\004\000\002\002\003\000\002\003\005\000" +
    "\002\003\006\000\002\003\007\000\002\003\011\000\002" +
    "\003\005\000\002\003\007\000\002\007\003\000\002\007" +
    "\005\000\002\010\003\000\002\010\003\000\002\010\005" +
    "\000\002\010\005\000\002\010\005\000\002\010\005\000" +
    "\002\010\005\000\002\010\005" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\103\000\004\025\005\001\002\000\004\002\105\001" +
    "\002\000\004\011\006\001\002\000\020\004\007\005\021" +
    "\007\012\017\017\023\014\026\016\031\013\001\002\000" +
    "\004\031\103\001\002\000\016\004\007\005\021\007\012" +
    "\017\017\023\014\031\013\001\002\000\026\004\007\005" +
    "\021\006\ufffa\007\012\017\017\021\ufffa\023\014\027\ufffa" +
    "\030\ufffa\031\013\001\002\000\010\020\025\031\024\033" +
    "\027\001\002\000\004\022\066\001\002\000\004\020\057" +
    "\001\002\000\020\004\ufffd\005\ufffd\007\ufffd\017\ufffd\023" +
    "\ufffd\026\016\031\ufffd\001\002\000\004\032\051\001\002" +
    "\000\004\032\047\001\002\000\004\030\045\001\002\000" +
    "\016\004\007\005\021\007\012\017\017\023\014\031\013" +
    "\001\002\000\004\006\023\001\002\000\010\020\025\031" +
    "\024\033\027\001\002\000\024\010\ufff0\011\ufff0\012\ufff0" +
    "\013\ufff0\014\ufff0\015\ufff0\016\ufff0\021\ufff0\024\ufff0\001" +
    "\002\000\010\020\025\031\024\033\027\001\002\000\016" +
    "\011\032\012\031\013\033\014\035\015\034\016\030\001" +
    "\002\000\024\010\ufff1\011\ufff1\012\ufff1\013\ufff1\014\ufff1" +
    "\015\ufff1\016\ufff1\021\ufff1\024\ufff1\001\002\000\010\020" +
    "\025\031\024\033\027\001\002\000\010\020\025\031\024" +
    "\033\027\001\002\000\026\004\ufff7\005\ufff7\006\ufff7\007" +
    "\ufff7\017\ufff7\021\ufff7\023\ufff7\027\ufff7\030\ufff7\031\ufff7" +
    "\001\002\000\010\020\025\031\024\033\027\001\002\000" +
    "\010\020\025\031\024\033\027\001\002\000\010\020\025" +
    "\031\024\033\027\001\002\000\024\010\uffed\011\uffed\012" +
    "\uffed\013\uffed\014\uffed\015\uffed\016\030\021\uffed\024\uffed" +
    "\001\002\000\024\010\uffec\011\uffec\012\uffec\013\uffec\014" +
    "\uffec\015\uffec\016\030\021\uffec\024\uffec\001\002\000\024" +
    "\010\uffee\011\uffee\012\uffee\013\uffee\014\035\015\034\016" +
    "\030\021\uffee\024\uffee\001\002\000\024\010\uffef\011\uffef" +
    "\012\uffef\013\uffef\014\035\015\034\016\030\021\uffef\024" +
    "\uffef\001\002\000\024\010\uffeb\011\uffeb\012\uffeb\013\uffeb" +
    "\014\uffeb\015\uffeb\016\uffeb\021\uffeb\024\uffeb\001\002\000" +
    "\016\012\031\013\033\014\035\015\034\016\030\021\044" +
    "\001\002\000\024\010\uffea\011\uffea\012\uffea\013\uffea\014" +
    "\uffea\015\uffea\016\uffea\021\uffea\024\uffea\001\002\000\004" +
    "\011\046\001\002\000\004\002\uffff\001\002\000\004\011" +
    "\050\001\002\000\026\004\ufff9\005\ufff9\006\ufff9\007\ufff9" +
    "\017\ufff9\021\ufff9\023\ufff9\027\ufff9\030\ufff9\031\ufff9\001" +
    "\002\000\004\011\052\001\002\000\016\004\007\005\021" +
    "\007\012\017\017\023\014\031\013\001\002\000\004\027" +
    "\054\001\002\000\004\011\055\001\002\000\020\004\ufffc" +
    "\005\ufffc\007\ufffc\017\ufffc\023\ufffc\026\ufffc\031\ufffc\001" +
    "\002\000\016\004\ufffe\005\ufffe\007\ufffe\017\ufffe\023\ufffe" +
    "\031\ufffe\001\002\000\010\020\025\031\024\033\027\001" +
    "\002\000\004\021\064\001\002\000\020\012\031\013\033" +
    "\014\035\015\034\016\030\021\ufff3\024\062\001\002\000" +
    "\010\020\025\031\024\033\027\001\002\000\004\021\ufff2" +
    "\001\002\000\004\011\065\001\002\000\026\004\ufff4\005" +
    "\ufff4\006\ufff4\007\ufff4\017\ufff4\021\ufff4\023\ufff4\027\ufff4" +
    "\030\ufff4\031\ufff4\001\002\000\010\020\025\031\024\033" +
    "\027\001\002\000\016\011\070\012\031\013\033\014\035" +
    "\015\034\016\030\001\002\000\026\004\ufff8\005\ufff8\006" +
    "\ufff8\007\ufff8\017\ufff8\021\ufff8\023\ufff8\027\ufff8\030\ufff8" +
    "\031\ufff8\001\002\000\016\010\072\012\031\013\033\014" +
    "\035\015\034\016\030\001\002\000\004\020\073\001\002" +
    "\000\016\004\007\005\021\007\012\017\017\023\014\031" +
    "\013\001\002\000\004\021\075\001\002\000\004\011\076" +
    "\001\002\000\026\004\ufff6\005\ufff6\006\ufff6\007\ufff6\017" +
    "\ufff6\021\ufff6\023\ufff6\027\ufff6\030\ufff6\031\ufff6\001\002" +
    "\000\012\006\ufffb\021\ufffb\027\ufffb\030\ufffb\001\002\000" +
    "\004\030\101\001\002\000\004\011\102\001\002\000\004" +
    "\002\000\001\002\000\004\011\104\001\002\000\026\004" +
    "\ufff5\005\ufff5\006\ufff5\007\ufff5\017\ufff5\021\ufff5\023\ufff5" +
    "\027\ufff5\030\ufff5\031\ufff5\001\002\000\004\002\001\001" +
    "\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\103\000\004\004\003\001\001\000\002\001\001\000" +
    "\002\001\001\000\012\002\017\003\010\005\007\006\014" +
    "\001\001\000\002\001\001\000\006\002\077\003\010\001" +
    "\001\000\006\002\076\003\010\001\001\000\004\010\070" +
    "\001\001\000\002\001\001\000\002\001\001\000\006\005" +
    "\055\006\014\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\002\021\003\010\001\001\000" +
    "\002\001\001\000\004\010\025\001\001\000\002\001\001" +
    "\000\004\010\042\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\010\041\001\001\000\004\010\040\001\001" +
    "\000\002\001\001\000\004\010\037\001\001\000\004\010" +
    "\036\001\001\000\004\010\035\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\006\002\052\003\010\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\006\007\057\010\060\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\007\062\010\060\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\010\066\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\006\002\073" +
    "\003\010\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {
 scanner.init();              
    }

  /** Scan to get the next Symbol. */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {
 return scanner.next_token(); 
    }


  public static void main(String args[]) throws java.io.IOException {
   parser parser_obj = new parser();
   Symbol parse_tree = null;
   try { parse_tree = parser_obj.parse(); }
   catch (Throwable e) {        e.printStackTrace();
        throw new Error(e.toString());
 };
}
        

/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
class CUP$parser$actions {

 


/**** interpStm ****/

/* This method a takes member of the statement class s
and a current table t and returns the table updated by s
(although some statements such as 'print' may not update the table).
It branches depending on what is the outermost constructor of s:
-If s is a print, it calls the method printList
with the list of expressions as first arg, and the current
table as second.  Print does NOT change the table.
-If s is an assignment, it returns the table value of the method
`update' when called with the current table, the assignment's
LHS, and the value of the RHS calcuated in the current table 
(note evaluating the RHS itself can't change the current table).
-If s is one statement s1 following by another s2, s2 is interpreted
in the table got by interpreting s1 in the current table t.
otherwise we have an error.  
-If s is a repeat statement, it returns the table after the
repeat's statements have been executed one or more times */

 Table interpStm(Stm s, FuncList fs, Table t) {
   if (s instanceof PrintStm)  
     {  printList(s.getExps(), t);
        return t;
     }
   else if (s instanceof AssignStm) {
        if (inTable(t, s.getLHS())) return update(t,s.getLHS(),interpExp(s.getRHS(), t));
        else System.out.println("ERROR: Using undeclared variable");
        return t; }
   else if (s instanceof CompoundStm)
        return interpStm(s.get2(), fs, interpStm(s.get1(),fs,t));
   else if (s instanceof CallStm)
        return interpStm(getFuncStms(s.getName(), fs), fs, t);
   else if (s instanceof RepeatStm) {
        /* first change table to simulate execution of stms inside repeat.. */
        Table table_temp = interpStm(s.getRepStm(),fs,t);
        /* find value of e in new table.. */
        int   int_temp = interpExp(s.getRepExp(),table_temp);
        /* call statements again if expression is non-zero */
        if (int_temp == 0) return table_temp; else
        return interpStm(s, fs, table_temp); }
   else if (s instanceof SelectionStm) {
        int temp = interpExp(s.getSelectionExp(), t);
        if (temp==0) { return t; }
        else { return interpStm(s.getSelectionStm(), fs, t); } }
   else if (s instanceof DecStm) {
        return update(t, s.getDecId(), 0); }
   else
        System.out.println("error in stm");
        return t;
  }

/**** interpExp ****/

/* interpExp takes an expression e and a table t and returns the
value of e within the context of t.
-If e is a number return that number.
-If e is an identifier, return the looked up value of id in table t.
-If e is a binary operator expression:
  get the value of the left expression and
  get the value of the right expression 
 return the value of the right and left expressions
 operated on by whatever binary operator we have.
otherwise we have an error */

 int interpExp(Exp e, Table t) {
  if (e instanceof NumExp) 
       return e.getInt();
  else if (e instanceof IdExp)
       return lookup(t,e.geteid());
  else if (e instanceof OpExp)
         {
            int   i_temp1 = interpExp(e.getleft(),t);
            int   i_temp2 = interpExp(e.getright(),t);
          if (e.getoper() == 1) 
           return (i_temp1+i_temp2); 
          else if (e.getoper() == 2) 
           return (i_temp1 - i_temp2); 
          else if (e.getoper() == 3) 
           return (i_temp1 * i_temp2); 
          else if (e.getoper() == 4) 
           return (i_temp1 / i_temp2); 
          else if (e.getoper() == 5 && i_temp1 > i_temp2) 
           return (1); 
          else if (e.getoper() == 5 && i_temp1 == i_temp2) 
           return (0); 
          else if (e.getoper() == 5 && i_temp1 < i_temp2) 
           return (0); 
          else throw new Error("error in Exp");
        }
  else throw new Error("Exp not recognised");
  }

/**** update ****/

/* constructor for a Table that implements the table
-- it simply adds the pair str, i to the old table t,
where str is the identifier and i the int value. */


 Table update(Table t,String str, int i) {
  return (new Table(str, i, t));}

/* selector for a Table - returns the integer value
associated with key once its found */


 int lookup(Table t, String key) {
  if (key.equals(t.getid())) return t.getint();
  else return lookup(t.gettail(),key);
  }

  boolean inTable(Table t, String key) {
    if (key.equals(t.getid())) return true;
    else if (t.gettail() == null) return false;
    else return inTable(t.gettail(), key);
  }

  Stm getFuncStms(String name, FuncList fs) {
    if (fs.getName().equals(name)) return fs.getStm();
    else return getFuncStms(name, fs.getTail());
  }


/* This class represents the Store of the program */

class Table {
  String id; int value; Table tail;
  Table(String i, int v, Table t)  {id =i; value=v; tail=t;}

  public String getid() {return id;}
  public int getint() {return value;}
  public Table gettail() {return tail;}
}


void  printList(ExpList expL, Table t) {
  if (expL instanceof PairExpList) 
     { 
       System.out.print(interpExp(expL.gethead(),t));
       System.out.print(" ");
       printList(  expL.gettail(), t );
      }
   else 
      /* exp is LastExpList */
              System.out.println(interpExp(expL.gethead(),t));
  }

/* The following classes represent the syntax classes of
   the language. They have constructirs and accesssors */

abstract class Stm { 
   protected ExpList getExps() {return null;}; 
   protected Stm get1() {return null;};
   protected Stm get2() {return null;};
   protected Exp getRHS() {return null;};
   protected String getLHS() {return null;};
   protected Stm getRepStm() {return null;};
   protected Exp getRepExp() {return null;};
   protected Stm getSelectionStm() { return null; }
   protected Exp getSelectionExp() { return null; }
   protected String getDecId() { return null; }
   protected String getName() { return null; }
}

class CompoundStm extends Stm {
   Stm stm1, stm2;
   CompoundStm(Stm s1, Stm s2) {stm1=s1; stm2=s2;}

   public Stm get1() {return stm1;}
   public Stm get2() {return stm2;}
}

class CallStm extends Stm {
    String name;
    CallStm(String n) {name =n; }
    public String getName() { return name; }
}

class AssignStm extends Stm {
   String id; Exp exp;
   AssignStm(String i, Exp e) {id=i; exp=e;}
   
   public Exp getRHS() {return exp;}
   public String getLHS() {return id;}
}

class PrintStm extends Stm {
   ExpList exps;
   PrintStm(ExpList e) {exps=e;}

   public ExpList getExps() {return exps;}
}
class RepeatStm extends Stm {
   Stm s; Exp exp;
   RepeatStm(Stm a, Exp e) {s=a; exp=e;}

   public Stm getRepStm() {return s;}
   public Exp getRepExp() {return exp;} 
}

class SelectionStm extends Stm {
    Stm s; Exp exp;
    SelectionStm(Stm a, Exp e) { s=a; exp=e; }

    public Stm getSelectionStm() { return s; }
    public Exp getSelectionExp() { return exp; }
}

class DecStm extends Stm {
    String id;
    DecStm(String i) { id=i; }

    public String getDecId() { return id; }
}

abstract class Exp {
   protected int getInt() { return 0;};
   protected String geteid() {return null;};
   protected Stm getStm()   {return null;}; 
   protected Exp getExp() {return null;};
   protected int getoper() {return 0;}
   protected Exp getleft() {return null;}
   protected Exp getright() {return null;}

   }

class IdExp extends Exp {
   String id;
   IdExp(String i) {id=i;}
   public String geteid() {return id;}  
}

class NumExp extends Exp {
   int num;
   NumExp(int n) {num=n;}
   public int getInt() {return num;}
}

class OpExp extends Exp {
   Exp left, right; int oper;
   final static int Plus=1,Minus=2,Times=3,Div=4,Gthan=5;
   OpExp(Exp l, int o, Exp r) {left=l; oper=o; right=r;}
   public int getoper() {return oper;}
   public Exp getleft() {return left;}
   public Exp getright() {return right;}
}

abstract class ExpList { 
   abstract Exp gethead() ;
   protected ExpList gettail() {return null;};
}

class PairExpList extends ExpList {
   Exp head; ExpList tail;
   PairExpList(Exp h, ExpList t) {head=h; tail=t;}

   public ExpList gettail() {return tail;}
   public Exp gethead() {return head;}
}

class LastExpList extends ExpList {
   Exp head; 
   LastExpList(Exp h) {head=h;}

   public Exp gethead() {return head;}
}

class FuncList {
    String name;
    Stm stm;
    FuncList tail;

    FuncList(String n, Stm s, FuncList t) { name=n; stm=s; tail=t; }

    String getName() { return name; }
    Stm getStm() { return stm; }
    FuncList getTail() { return tail; }
}
            
  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$parser$do_action_part00000000(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= prog EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Table start_val = (Table)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // prog ::= START SEMI func stm FINISH SEMI 
            {
              Table RESULT =null;
		int fsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int fsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		FuncList fs = (FuncList)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Stm s = (Stm)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		 RESULT = interpStm(s,fs,new Table("",0,null)); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("prog",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // prog ::= START SEMI stm FINISH SEMI 
            {
              Table RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Stm s = (Stm)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		 RESULT = interpStm(s,null,new Table("",0,null));  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("prog",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // func ::= single_func func 
            {
              FuncList RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		FuncList f = (FuncList)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int fsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		FuncList fs = (FuncList)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new FuncList(f.getName(), f.getStm(), fs); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("func",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // func ::= single_func 
            {
              FuncList RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		FuncList s = (FuncList)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("func",3, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // single_func ::= FUNCTION FUNCNAME SEMI stm END SEMI 
            {
              FuncList RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Stm s = (Stm)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		 RESULT = new FuncList(name, s, null); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("single_func",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // stm ::= single_stm stm 
            {
              Stm RESULT =null;
		int s1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int s1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Stm s1 = (Stm)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int s2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int s2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Stm s2 = (Stm)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new CompoundStm(s1,s2); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("stm",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // stm ::= single_stm 
            {
              Stm RESULT =null;
		int s1left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int s1right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Stm s1 = (Stm)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = s1; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("stm",0, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // single_stm ::= CALL FUNCNAME SEMI 
            {
              Stm RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String f = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = new CallStm(f); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("single_stm",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // single_stm ::= ID ASSIGNS exp SEMI 
            {
              Stm RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = new AssignStm(id,e); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("single_stm",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // single_stm ::= DO stm WHILE exp SEMI 
            {
              Stm RESULT =null;
		int s1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int s1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Stm s1 = (Stm)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = new RepeatStm(s1,e); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("single_stm",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // single_stm ::= IF exp THEN LPAREN stm RPAREN SEMI 
            {
              Stm RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Stm s = (Stm)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		 RESULT = new SelectionStm(s, e); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("single_stm",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // single_stm ::= VARDEC ID SEMI 
            {
              Stm RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = new DecStm(id); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("single_stm",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // single_stm ::= PRINT LPAREN exps RPAREN SEMI 
            {
              Stm RESULT =null;
		int esleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int esright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ExpList es = (ExpList)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		 RESULT = new PrintStm(es); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("single_stm",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // exps ::= exp 
            {
              ExpList RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new LastExpList(e); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exps",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // exps ::= exp COMMA exps 
            {
              ExpList RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int esleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int esright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ExpList es = (ExpList)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new PairExpList(e,es); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exps",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // exp ::= INT 
            {
              Exp RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Integer n = (Integer)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new NumExp(n.intValue()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp",6, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // exp ::= ID 
            {
              Exp RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = new IdExp(id);
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp",6, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // exp ::= exp PLUS exp 
            {
              Exp RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new OpExp(e1,OpExp.Plus,e2); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // exp ::= exp MINUS exp 
            {
              Exp RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new OpExp(e1,OpExp.Minus,e2); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // exp ::= exp TIMES exp 
            {
              Exp RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new OpExp(e1,OpExp.Times,e2); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // exp ::= exp DIVIDE exp 
            {
              Exp RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new OpExp(e1,OpExp.Div,e2); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // exp ::= exp GT exp 
            {
              Exp RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new OpExp(e1,OpExp.Gthan,e2); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // exp ::= LPAREN exp RPAREN 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = e; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$parser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
              return CUP$parser$do_action_part00000000(
                               CUP$parser$act_num,
                               CUP$parser$parser,
                               CUP$parser$stack,
                               CUP$parser$top);
    }
}

}
